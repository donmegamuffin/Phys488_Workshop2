\documentclass{article}
\usepackage{amsmath}
\usepackage{caption}
\usepackage{graphicx}
\usepackage{yfonts}
\usepackage{listings}
\usepackage{lipsum}
\usepackage{multicol}
\usepackage{hyperref}
	\title{PHYS488: Week1 - General Excerises}
	\author{Zachary Humphreys \\ 200951438}	
	\date{30/1/2017}
	\lstset{basicstyle=\tiny}
	
\begin{document}
	\maketitle
	\begin{abstract}
		\begin{center}
		\textit{This weeks set of tasks focused on learning about loops, if functions, and arrays, and involved executing some sample programs provided for Task 1, updating a program created last week to be done using arrays, and loops in Task 2, and learning how to export data from code by writing to an .csv file in Task 3.}
		\end{center}
	\end{abstract}
%Main Body of text in 2Column format
\begin{multicols}{2}
	\section{Task 1}
		In this task, five java programs were provided and each of these codes were to be run and inspected to see how they work. These programs were imported into BlueJ and, in the case of \textit{FindRoots.java}, corrected and executed.
		\subsection{SimpleSum.java}
			 This program was created to demonstrate the overall structure of how Java programs should be written, and specifically to demonstrate how to implement methods within a class. \\ \indent Lines 9 through 16 show a simple method that takes two \textit{double} variable inputs and outputs another \textit{double} variable with the value of the two inputs added together as it returns \textit{sum} which is a variable stated and calculated with lines 12 and 13. \\ \indent The main method then proceeds with asking the user to input two different variables into the console then uses the method from earlier in line 25 to calculate the sum of these two variables with:
			 \begin{lstlisting}
double ans = getsum(first, second);
			 \end{lstlisting} 
			 which returns the sum and in the subsequent line, this is printed to the user in the console
		\subsection{FindRoots.java}
			This program iterated on the demonstrations shown in \textit{SimpleSum.java} by having a similar structure of one short method and a main method handling most of the work. \\ \indent The method, like previous, takes two \textit{double} argument (inputs) and returns (outputs) a \textit{double}. However, the method is slightly more complicated than the previous program: instead of simply summing the two inputs, it finds the $n^{th}$ root of the $x$ input by returning the exponential of line 15. \\ \indent There are four provided examples of this method being called in the main method, with the last one failing to work (line 27):
			\begin{lstlisting}
screen.println(" The 3/2  root of 9*9*9 =  " + nthRoot(9*9*9,3/2));
			\end{lstlisting} 
			which returns the value 729, as if no $n^{th}$ root had been applied. This is due to the fact that the n given in the function is $3/2$ where java treats both values as integers, hence returning the value 1. By simply changing it to $(3./2)$, Java no longer treats the 3 as an integer and it returns the correct value, same as the line of code above it.
		\subsection{SimpleLoops.java}
			This code is different from the other two as it only consists of a single main, though it has two separate functions within it.
			The first function demonstrates a \textit{for} loop for a loop where the number of iterations to be done is well known. It's contained within lines 14 to 16 and simply takes the iterations number, \textit{n}, and raises it to the power of itself. \\ \indent The second section in the main simply demonstrates how to use a \textit{while} loop to produce a simple number guessing game that keeps looping until the user's answer is equal to the randomly generated number in line 23. Within this while loop it has an \textit{if/else} statement between lines 28 and 32 that finishes the print line from above with either higher or lower depending on whether the guess is higher or lower respectively. \\ \indent If the user finally inputs the correct value, the while loop will stop and print a line congratulating the player. Unfortunately, if the player is not good at guessing, it could potentially form an infinite loop.
		\subsection{SimpleArray.java}
			This program demonstrates a way to input an array of a length $numberToStore$ determined by the user. It then uses this value to determined the maximum number of loops in the \textit{for} loop starting on line 16, which asks the user to input each number followed by an enter in turn to be put into the array. The second \textit{for} loop is used to output each of the numbers from the compiled array to check if these were the values the user wanted.
		\subsection{Interpolate.java}
			The overall function of this program is to take an input from the user and output an estimated reaction cross section sigma value. It did this by first having an array of values for the cross section in line 14. These effectively provided a framework for the curve by having the values calculated at exact energy intervals of 10 MeV. The while function on lines 28 through 54 would loop as long as the user did not input a zero, and would ask the user to input an energy. \\ \indent The energy inputted by the user would then have it's array element number calculated on line 36 with lines 39 to 42 doing a quick check to make sure the value inputted actually fell into the energy range of a bin. \\ \indent Lines 44 to 48 gave the bin's element number, and the energy range it fell into, and lines 51 to 53 then did a quick interpolation by first finding how close it was the top end of the bin, and using this weighting in line 52 to do a weighted average of the cross section values assosiated to the energy values of the bin and then outputted this weighted average sigma value to the console in line 53.
	\section{Task 2}
		\subsection{Methodology}
		This task involved modifying the code for the last section of week 1's set of tasks to reduce the number variables and replace them with arrays instead, and to reduce repetition in the code and replace repeatable bits with loops instead. \\ \indent To first start this task, I started by writing down on paper in "pseudocode" what I wanted my program to do, and how to do it. The initial ideas, though almost identical in structure to the final implementation, was very different in the techniques used as new and alternative techniques were learnt in the few days trying to achieve the program I envisioned. \\ \indent This meant a fair amount of extra knowledge not contained within the lecture had be learnt and adapted to get my code to work how I wanted it to, and this was done mostly through the use of recommended textbook \footnote{J. Hubbard, Programming with Java,(2004), 2nd edition, McGraw-Hill. } and Oracle's own documentation online concerning their code. The initial paper plan for the program went thus:
		\begin{lstlisting}
Class 4Vecs V2
  Method: 4Vec ToArray      (1)
  Method: 4Vec MomentumCalc (2)
  Method: 4Vec MassCalc     (3)
  Method: 4Vec Adder        (4)
  Main:   Loop(n from 0 to 1 ) {
	  Input 4Vec_n as seperate variables
      Do methods (1), (2), (3) }
      Use (4) to add 4Vec_0 and 4Vec_1
      Do (2) (3)
      Output answers to console - END
		\end{lstlisting}
		Unfortunately, after a few hours with this plan, two big problems occurred: Issues using two arrays as arguments for methods, and getting a loop to produce variables with a suffix $"_ n"$ where n was the loop number which could be used for calculations in the loop. Another problem was the clumsy unclear main, filled with more complex code than some of the methods making it hard to understand and read. Instead, this iteration was almost entirely scrapped with only some of the shells of the methods intact, such as the discovery that it was much easier to implement a method to calculate both the Momentum and the invariant mass of the given four vector, and was much fewer lines of code as a result.
		
		As a by-product of learning about multiple arrays as arguments to a method, 2D arrays were discovered, and from there, a new cleaner strategy was implemented. The paper code was rewritten and revisualised for clarity and the final paper iteration for the framework was thus:
		\begin{lstlisting}
Class 4Vecs V2.1
  Method: 4Vec Array Builder (1)
  Method: 4Vec Mass and Momentum Extractor (2)
  Method: 4Vec Array Adder (3)
  Main:   4VecArray = (1)
     MassMomentumArray = (2)
     4VecAddedArray= (3)
     AddedMassMomentumArray = (2)
     Print needed stuff - END
		\end{lstlisting}
		 This iteration, at first, still contained a mix of 1D and 2D arrays for calculations, but eventually, the entire framework was readjusted to accepted 2D arrays at every input and output for all the methods for consistency. \footnote{The history of this program during the later stages can be viewed at  \url{https://github.com/donmegamuffin/Phys488_Workshop2}}   %TODO "THE VISUALISATION IS IN APPEND 
			\subsection{Method 1 - ArrayCompiler}
			The first method, the Array Builder (lines 15 to 32), was created to take a string of numbers from the user and convert them into usable \textit{double}s for calculations later on, built into a 2D array, where each array row was a four vector. As the question only required calculation for two four vectors, the for loops number of loops are baked in to have them. The \textit{for} loop on line 20 deals with the four-vectors as a whole, where it requests the user to input into the console the four vector in the format:
			\begin{lstlisting}
	 000 000 000 000
e.g. 150 040 -35 -20
			\end{lstlisting}
			and the second \textit{for} loop would pull substrings out of the input string and convert them into \textit{double} array elements. \\ \indent This had a couple of limitations: all values had to be integers, positive values could only go up to a maximum of 999 and negatives were limited to -99 as - took up a character slot. This was due to the fact I could not find out how to code it to read a number up to an empty space and then turn everything up to then into a number, to then continue onwards to the next number, etc. However, for the values requested in the Task, this was more than sufficient. \\ \indent The output of this method was an output of a 2D Array with each vector stored in one row.
			\subsection{Method 2 - ArrayMandPExtractor}
			This method, took one of the four-vector 2D arrays, and would then calculate the absolute momentum and invariant mass (lines 40 and 41) for both vectors, and place them into a 2x2 2D matrix from earlier, again, with each vectors values placed in separate rows.
			\subsection{Method 3 - ArrayAdder}
			Again, this is another simple Method that initialises a two row, four column array and takes the input four vector array, and adds the values from row 2 to row 1 and outputs this new 2D array.
			\subsection{Method 4 - ConsoleWriter}
			To make the main method more readable, all the code that was used to write the solutions to the console was moved to a separate method, which takes 3 arguments which are all the 2D matrices generated so far. This was initially done with the function:
			\begin{lstlisting}
import java.util.Arrays;
...
...
screen.println(Array.deepToString())
			\end{lstlisting}
			to print the arrays to the console in as few lines as possible, but unfortunately doesn't give any context to the numbers, so was replaced after the debugging.
			\subsection{Main}
			This section is now much cleaner than the original implementation consisting of only 5 lines of code, 4 of which (lines 79 to 82) are simply 2D array definitions with the final one of these (line 84) taking these arrays and applying them to the ConsoleWriter method. This method is, as a result, now much easier to read and understand as much of it is written in almost plain English.
	\section{Task 3}
		\begin{table*}[h]
			\title{Task3.1}
			\begin{lstlisting}
41 final double binlow  = 0.4; // this is the low edge of the first bin , hist1[0].       
42 final double binhigh = 0.9; // this is the upper edge of the last bin, hist1[SIZE-1].  
43 long numberUnderflows=0; // this is the number of random values that fall below binlow.
44 long numberOverflows=0; // this is the number of random values that fall above binhigh. 
48 double [] histError = new double[SIZE]; // Empty array is filled zeroes  
92 screen.printf("Bin number " + bin + " contents =  " +  hist[bin]+ ";error = " + "%.3f", histError[bin]);
93 screen.println(" ("+ (hist[bin]/histError[bin]) +"%)");                
97 screen.println("The number of random numbers overflowed: " +numberOverflows);
98 screen.println("The number of random numbers underflowed: " +numberUnderflows); 
\end{lstlisting}
\title{Task3.2}
\begin{lstlisting}
21  outputFile.println("ntrials  , " + trials); 
22  outputFile.println("#Underflowed  , " + under); 
23  outputFile.println("#Overflowed  , " + over); 
69  if(randNumber <=binlow || randNumber >=binhigh) // <<TASK 3.2>>> Under/Over
70  {
72 		 if(randNumber <=binlow)
73 		 {
74  		 numberUnderflows++;
75  	 }
76  	if(randNumber >=binhigh)
77  	{
78 		  numberOverflows++;
79  	}
80  }
100 writeToDisk(hist, binlow, binsize, trials, numberUnderflows, numberOverflows, "test.csv"); 
	\end{lstlisting}
\end{table*}
		\subsection{Task3.1}

		\subsection{Task3.2}
			
			



\end{multicols}
\newpage


%Appendixes for Codedump
\title{Appendices}
\begin{center}

%TODO
\begin{lstlisting}

\end{lstlisting}

\end{center}
\end{document}